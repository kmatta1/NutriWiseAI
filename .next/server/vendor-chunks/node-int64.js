/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-int64";
exports.ids = ["vendor-chunks/node-int64"];
exports.modules = {

/***/ "(action-browser)/./node_modules/node-int64/Int64.js":
/*!******************************************!*\
  !*** ./node_modules/node-int64/Int64.js ***!
  \******************************************/
/***/ ((module) => {

eval("//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n\n// Useful masks and values for bit twiddling\nvar MASK31 =  0x7fffffff, VAL31 = 0x80000000;\nvar MASK32 =  0xffffffff, VAL32 = 0x100000000;\n\n// Map for converting hex octets to strings\nvar _HEX = [];\nfor (var i = 0; i < 256; i++) {\n  _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n}\n\n//\n// Int64\n//\n\n/**\n * Constructor accepts any of the following argument types:\n *\n * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n * new Int64(string)             - Hex string (throws if n is outside int64 range)\n * new Int64(number)             - Number (throws if n is outside int64 range)\n * new Int64(hi, lo)             - Raw bits as two 32-bit values\n */\nvar Int64 = module.exports = function(a1, a2) {\n  if (a1 instanceof Buffer) {\n    this.buffer = a1;\n    this.offset = a2 || 0;\n  } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n    // Under Browserify, Buffers can extend Uint8Arrays rather than an\n    // instance of Buffer. We could assume the passed in Uint8Array is actually\n    // a buffer but that won't handle the case where a raw Uint8Array is passed\n    // in. We construct a new Buffer just in case.\n    this.buffer = new Buffer(a1);\n    this.offset = a2 || 0;\n  } else {\n    this.buffer = this.buffer || new Buffer(8);\n    this.offset = 0;\n    this.setValue.apply(this, arguments);\n  }\n};\n\n\n// Max integer value that JS can accurately represent\nInt64.MAX_INT = Math.pow(2, 53);\n\n// Min integer value that JS can accurately represent\nInt64.MIN_INT = -Math.pow(2, 53);\n\nInt64.prototype = {\n\n  constructor: Int64,\n\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  _2scomp: function() {\n    var b = this.buffer, o = this.offset, carry = 1;\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  },\n\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  setValue: function(hi, lo) {\n    var negate = false;\n    if (arguments.length == 1) {\n      if (typeof(hi) == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % VAL32;\n        hi = hi / VAL32;\n        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof(hi) == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    }\n\n    // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n\n    // Copy bytes to buffer\n    var b = this.buffer, o = this.offset;\n    for (var i = 7; i >= 0; i--) {\n      b[o+i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    }\n\n    // Restore sign of passed argument\n    if (negate) this._2scomp();\n  },\n\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   */\n  toNumber: function(allowImprecise) {\n    var b = this.buffer, o = this.offset;\n\n    // Running sum of octets, doing a 2's complement\n    var negate = b[o] & 0x80, x = 0, carry = 1;\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o+i];\n\n      // 2's complement for negative numbers\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n    }\n\n    // Return Infinity if we've lost integer precision\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  },\n\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   */\n  valueOf: function() {\n    return this.toNumber(false);\n  },\n\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  toString: function(radix) {\n    return this.valueOf().toString(radix || 10);\n  },\n\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   *\n   * @param sep separator string. default is '' (empty string)\n   */\n  toOctetString: function(sep) {\n    var out = new Array(8);\n    var b = this.buffer, o = this.offset;\n    for (var i = 0; i < 8; i++) {\n      out[i] = _HEX[b[o+i]];\n    }\n    return out.join(sep || '');\n  },\n\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   *\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   */\n  toBuffer: function(rawBuffer) {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n\n    var out = new Buffer(8);\n    this.buffer.copy(out, 0, this.offset, this.offset + 8);\n    return out;\n  },\n\n  /**\n   * Copy 8 bytes of int64 into target buffer at target offset.\n   *\n   * @param {Buffer} targetBuffer       Buffer to copy into.\n   * @param {number} [targetOffset=0]   Offset into target buffer.\n   */\n  copy: function(targetBuffer, targetOffset) {\n    this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);\n  },\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  compare: function(other) {\n\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    }\n\n    // otherwise, compare bytes lexicographically\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {\n        return this.buffer[this.offset+i] - other.buffer[other.offset+i];\n      }\n    }\n    return 0;\n  },\n\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  equals: function(other) {\n    return this.compare(other) === 0;\n  },\n\n  /**\n   * Pretty output in console.log\n   */\n  inspect: function() {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ub2RlLWludDY0L0ludDY0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxccmVwb1xcTnV0cmlXaXNlQUlcXG5vZGVfbW9kdWxlc1xcbm9kZS1pbnQ2NFxcSW50NjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIEludDY0LmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMiBSb2JlcnQgS2llZmZlclxuLy8gICAgIE1JVCBMaWNlbnNlIC0gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXG4vKipcbiAqIFN1cHBvcnQgZm9yIGhhbmRsaW5nIDY0LWJpdCBpbnQgbnVtYmVycyBpbiBKYXZhc2NyaXB0IChub2RlLmpzKVxuICpcbiAqIEpTIE51bWJlcnMgYXJlIElFRUUtNzU0IGJpbmFyeSBkb3VibGUtcHJlY2lzaW9uIGZsb2F0cywgd2hpY2ggbGltaXRzIHRoZVxuICogcmFuZ2Ugb2YgdmFsdWVzIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIHdpdGggaW50ZWdlciBwcmVjaXNpb24gdG86XG4gKlxuICogMl5eNTMgPD0gTiA8PSAyXjUzXG4gKlxuICogSW50NjQgb2JqZWN0cyB3cmFwIGEgbm9kZSBCdWZmZXIgdGhhdCBob2xkcyB0aGUgOC1ieXRlcyBvZiBpbnQ2NCBkYXRhLiAgVGhlc2VcbiAqIG9iamVjdHMgb3BlcmF0ZSBkaXJlY3RseSBvbiB0aGUgYnVmZmVyIHdoaWNoIG1lYW5zIHRoYXQgaWYgdGhleSBhcmUgY3JlYXRlZFxuICogdXNpbmcgYW4gZXhpc3RpbmcgYnVmZmVyIHRoZW4gc2V0dGluZyB0aGUgdmFsdWUgd2lsbCBtb2RpZnkgdGhlIEJ1ZmZlciwgYW5kXG4gKiB2aWNlLXZlcnNhLlxuICpcbiAqIEludGVybmFsIFJlcHJlc2VudGF0aW9uXG4gKlxuICogVGhlIGludGVybmFsIGJ1ZmZlciBmb3JtYXQgaXMgQmlnIEVuZGlhbi4gIEkuZS4gdGhlIG1vc3Qtc2lnbmlmaWNhbnQgYnl0ZSBpc1xuICogYXQgYnVmZmVyWzBdLCB0aGUgbGVhc3Qtc2lnbmlmaWNhbnQgYXQgYnVmZmVyWzddLiAgRm9yIHRoZSBwdXJwb3NlcyBvZlxuICogY29udmVydGluZyB0by9mcm9tIEpTIG5hdGl2ZSBudW1iZXJzLCB0aGUgdmFsdWUgaXMgYXNzdW1lZCB0byBiZSBhIHNpZ25lZFxuICogaW50ZWdlciBzdG9yZWQgaW4gMidzIGNvbXBsZW1lbnQgZm9ybS5cbiAqXG4gKiBGb3IgZGV0YWlscyBhYm91dCBJRUVFLTc1NCBzZWU6XG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJsZV9wcmVjaXNpb25fZmxvYXRpbmctcG9pbnRfZm9ybWF0XG4gKi9cblxuLy8gVXNlZnVsIG1hc2tzIGFuZCB2YWx1ZXMgZm9yIGJpdCB0d2lkZGxpbmdcbnZhciBNQVNLMzEgPSAgMHg3ZmZmZmZmZiwgVkFMMzEgPSAweDgwMDAwMDAwO1xudmFyIE1BU0szMiA9ICAweGZmZmZmZmZmLCBWQUwzMiA9IDB4MTAwMDAwMDAwO1xuXG4vLyBNYXAgZm9yIGNvbnZlcnRpbmcgaGV4IG9jdGV0cyB0byBzdHJpbmdzXG52YXIgX0hFWCA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBfSEVYW2ldID0gKGkgPiAweEYgPyAnJyA6ICcwJykgKyBpLnRvU3RyaW5nKDE2KTtcbn1cblxuLy9cbi8vIEludDY0XG4vL1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIGFjY2VwdHMgYW55IG9mIHRoZSBmb2xsb3dpbmcgYXJndW1lbnQgdHlwZXM6XG4gKlxuICogbmV3IEludDY0KGJ1ZmZlclssIG9mZnNldD0wXSkgLSBFeGlzdGluZyBCdWZmZXIgd2l0aCBieXRlIG9mZnNldFxuICogbmV3IEludDY0KFVpbnQ4QXJyYXlbLCBvZmZzZXQ9MF0pIC0gRXhpc3RpbmcgVWludDhBcnJheSB3aXRoIGEgYnl0ZSBvZmZzZXRcbiAqIG5ldyBJbnQ2NChzdHJpbmcpICAgICAgICAgICAgIC0gSGV4IHN0cmluZyAodGhyb3dzIGlmIG4gaXMgb3V0c2lkZSBpbnQ2NCByYW5nZSlcbiAqIG5ldyBJbnQ2NChudW1iZXIpICAgICAgICAgICAgIC0gTnVtYmVyICh0aHJvd3MgaWYgbiBpcyBvdXRzaWRlIGludDY0IHJhbmdlKVxuICogbmV3IEludDY0KGhpLCBsbykgICAgICAgICAgICAgLSBSYXcgYml0cyBhcyB0d28gMzItYml0IHZhbHVlc1xuICovXG52YXIgSW50NjQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGExLCBhMikge1xuICBpZiAoYTEgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGExO1xuICAgIHRoaXMub2Zmc2V0ID0gYTIgfHwgMDtcbiAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYTEpID09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJykge1xuICAgIC8vIFVuZGVyIEJyb3dzZXJpZnksIEJ1ZmZlcnMgY2FuIGV4dGVuZCBVaW50OEFycmF5cyByYXRoZXIgdGhhbiBhblxuICAgIC8vIGluc3RhbmNlIG9mIEJ1ZmZlci4gV2UgY291bGQgYXNzdW1lIHRoZSBwYXNzZWQgaW4gVWludDhBcnJheSBpcyBhY3R1YWxseVxuICAgIC8vIGEgYnVmZmVyIGJ1dCB0aGF0IHdvbid0IGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhIHJhdyBVaW50OEFycmF5IGlzIHBhc3NlZFxuICAgIC8vIGluLiBXZSBjb25zdHJ1Y3QgYSBuZXcgQnVmZmVyIGp1c3QgaW4gY2FzZS5cbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXIoYTEpO1xuICAgIHRoaXMub2Zmc2V0ID0gYTIgfHwgMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyIHx8IG5ldyBCdWZmZXIoOCk7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMuc2V0VmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuXG4vLyBNYXggaW50ZWdlciB2YWx1ZSB0aGF0IEpTIGNhbiBhY2N1cmF0ZWx5IHJlcHJlc2VudFxuSW50NjQuTUFYX0lOVCA9IE1hdGgucG93KDIsIDUzKTtcblxuLy8gTWluIGludGVnZXIgdmFsdWUgdGhhdCBKUyBjYW4gYWNjdXJhdGVseSByZXByZXNlbnRcbkludDY0Lk1JTl9JTlQgPSAtTWF0aC5wb3coMiwgNTMpO1xuXG5JbnQ2NC5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IEludDY0LFxuXG4gIC8qKlxuICAgKiBEbyBpbi1wbGFjZSAyJ3MgY29tcGxpbWVudC4gIFNlZVxuICAgKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3bydzX2NvbXBsZW1lbnRcbiAgICovXG4gIF8yc2NvbXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiID0gdGhpcy5idWZmZXIsIG8gPSB0aGlzLm9mZnNldCwgY2FycnkgPSAxO1xuICAgIGZvciAodmFyIGkgPSBvICsgNzsgaSA+PSBvOyBpLS0pIHtcbiAgICAgIHZhciB2ID0gKGJbaV0gXiAweGZmKSArIGNhcnJ5O1xuICAgICAgYltpXSA9IHYgJiAweGZmO1xuICAgICAgY2FycnkgPSB2ID4+IDg7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlLiBUYWtlcyBhbnkgb2YgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAqXG4gICAqIHNldFZhbHVlKHN0cmluZykgLSBBIGhleGlkZWNpbWFsIHN0cmluZ1xuICAgKiBzZXRWYWx1ZShudW1iZXIpIC0gTnVtYmVyICh0aHJvd3MgaWYgbiBpcyBvdXRzaWRlIGludDY0IHJhbmdlKVxuICAgKiBzZXRWYWx1ZShoaSwgbG8pIC0gUmF3IGJpdHMgYXMgdHdvIDMyLWJpdCB2YWx1ZXNcbiAgICovXG4gIHNldFZhbHVlOiBmdW5jdGlvbihoaSwgbG8pIHtcbiAgICB2YXIgbmVnYXRlID0gZmFsc2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKHR5cGVvZihoaSkgPT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gU2ltcGxpZnkgYml0ZmllbGQgcmV0cmlldmFsIGJ5IHVzaW5nIGFicygpIHZhbHVlLiAgV2UgcmVzdG9yZSBzaWduXG4gICAgICAgIC8vIGxhdGVyXG4gICAgICAgIG5lZ2F0ZSA9IGhpIDwgMDtcbiAgICAgICAgaGkgPSBNYXRoLmFicyhoaSk7XG4gICAgICAgIGxvID0gaGkgJSBWQUwzMjtcbiAgICAgICAgaGkgPSBoaSAvIFZBTDMyO1xuICAgICAgICBpZiAoaGkgPiBWQUwzMikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaGkgICsgJyBpcyBvdXRzaWRlIEludDY0IHJhbmdlJyk7XG4gICAgICAgIGhpID0gaGkgfCAwO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaGkpID09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhpID0gKGhpICsgJycpLnJlcGxhY2UoL14weC8sICcnKTtcbiAgICAgICAgbG8gPSBoaS5zdWJzdHIoLTgpO1xuICAgICAgICBoaSA9IGhpLmxlbmd0aCA+IDggPyBoaS5zdWJzdHIoMCwgaGkubGVuZ3RoIC0gOCkgOiAnJztcbiAgICAgICAgaGkgPSBwYXJzZUludChoaSwgMTYpO1xuICAgICAgICBsbyA9IHBhcnNlSW50KGxvLCAxNik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaGkgKyAnIG11c3QgYmUgYSBOdW1iZXIgb3IgU3RyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVjaG5pY2FsbHkgd2Ugc2hvdWxkIHRocm93IGlmIGhpIG9yIGxvIGlzIG91dHNpZGUgaW50MzIgcmFuZ2UgaGVyZSwgYnV0XG4gICAgLy8gaXQncyBub3Qgd29ydGggdGhlIGVmZm9ydC4gQW55dGhpbmcgcGFzdCB0aGUgMzInbmQgYml0IGlzIGlnbm9yZWQuXG5cbiAgICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlclxuICAgIHZhciBiID0gdGhpcy5idWZmZXIsIG8gPSB0aGlzLm9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGJbbytpXSA9IGxvICYgMHhmZjtcbiAgICAgIGxvID0gaSA9PSA0ID8gaGkgOiBsbyA+Pj4gODtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIHNpZ24gb2YgcGFzc2VkIGFyZ3VtZW50XG4gICAgaWYgKG5lZ2F0ZSkgdGhpcy5fMnNjb21wKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBuYXRpdmUgSlMgbnVtYmVyLlxuICAgKlxuICAgKiBXQVJOSU5HOiBEbyBub3QgZXhwZWN0IHRoaXMgdmFsdWUgdG8gYmUgYWNjdXJhdGUgdG8gaW50ZWdlciBwcmVjaXNpb24gZm9yXG4gICAqIGxhcmdlIChwb3NpdGl2ZSBvciBuZWdhdGl2ZSkgbnVtYmVycyFcbiAgICpcbiAgICogQHBhcmFtIGFsbG93SW1wcmVjaXNlIElmIHRydWUsIG5vIGNoZWNrIGlzIHBlcmZvcm1lZCB0byB2ZXJpZnkgdGhlXG4gICAqIHJldHVybmVkIHZhbHVlIGlzIGFjY3VyYXRlIHRvIGludGVnZXIgcHJlY2lzaW9uLiAgSWYgZmFsc2UsIGltcHJlY2lzZVxuICAgKiBudW1iZXJzICh2ZXJ5IGxhcmdlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlcnMpIHdpbGwgYmUgZm9yY2VkIHRvICsvLVxuICAgKiBJbmZpbml0eS5cbiAgICovXG4gIHRvTnVtYmVyOiBmdW5jdGlvbihhbGxvd0ltcHJlY2lzZSkge1xuICAgIHZhciBiID0gdGhpcy5idWZmZXIsIG8gPSB0aGlzLm9mZnNldDtcblxuICAgIC8vIFJ1bm5pbmcgc3VtIG9mIG9jdGV0cywgZG9pbmcgYSAyJ3MgY29tcGxlbWVudFxuICAgIHZhciBuZWdhdGUgPSBiW29dICYgMHg4MCwgeCA9IDAsIGNhcnJ5ID0gMTtcbiAgICBmb3IgKHZhciBpID0gNywgbSA9IDE7IGkgPj0gMDsgaS0tLCBtICo9IDI1Nikge1xuICAgICAgdmFyIHYgPSBiW28raV07XG5cbiAgICAgIC8vIDIncyBjb21wbGVtZW50IGZvciBuZWdhdGl2ZSBudW1iZXJzXG4gICAgICBpZiAobmVnYXRlKSB7XG4gICAgICAgIHYgPSAodiBeIDB4ZmYpICsgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gdiA+PiA4O1xuICAgICAgICB2ID0gdiAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIHggKz0gdiAqIG07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIEluZmluaXR5IGlmIHdlJ3ZlIGxvc3QgaW50ZWdlciBwcmVjaXNpb25cbiAgICBpZiAoIWFsbG93SW1wcmVjaXNlICYmIHggPj0gSW50NjQuTUFYX0lOVCkge1xuICAgICAgcmV0dXJuIG5lZ2F0ZSA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBuZWdhdGUgPyAteCA6IHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBKUyBOdW1iZXIuIFJldHVybnMgKy8tSW5maW5pdHkgZm9yIHZhbHVlcyB0aGF0IGNhbid0IGJlXG4gICAqIHJlcHJlc2VudGVkIHRvIGludGVnZXIgcHJlY2lzaW9uLlxuICAgKi9cbiAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9OdW1iZXIoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gc3RyaW5nIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSByYWRpeCBKdXN0IGxpa2UgTnVtYmVyI3RvU3RyaW5nKCkncyByYWRpeFxuICAgKi9cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKHJhZGl4KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVPZigpLnRvU3RyaW5nKHJhZGl4IHx8IDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgc3RyaW5nIHNob3dpbmcgdGhlIGJ1ZmZlciBvY3RldHMsIHdpdGggTVNCIG9uIHRoZSBsZWZ0LlxuICAgKlxuICAgKiBAcGFyYW0gc2VwIHNlcGFyYXRvciBzdHJpbmcuIGRlZmF1bHQgaXMgJycgKGVtcHR5IHN0cmluZylcbiAgICovXG4gIHRvT2N0ZXRTdHJpbmc6IGZ1bmN0aW9uKHNlcCkge1xuICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoOCk7XG4gICAgdmFyIGIgPSB0aGlzLmJ1ZmZlciwgbyA9IHRoaXMub2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBfSEVYW2JbbytpXV07XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbihzZXAgfHwgJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnQ2NCdzIDggYnl0ZXMgaW4gYSBidWZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbH0gW3Jhd0J1ZmZlcj1mYWxzZV0gIElmIG5vIG9mZnNldCBhbmQgdGhpcyBpcyB0cnVlLCByZXR1cm4gdGhlIGludGVybmFsIGJ1ZmZlci4gIFNob3VsZCBvbmx5IGJlIHVzZWQgaWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeW91J3JlIGRpc2NhcmRpbmcgdGhlIEludDY0IGFmdGVyd2FyZHMsIGFzIGl0IGJyZWFrcyBlbmNhcHN1bGF0aW9uLlxuICAgKi9cbiAgdG9CdWZmZXI6IGZ1bmN0aW9uKHJhd0J1ZmZlcikge1xuICAgIGlmIChyYXdCdWZmZXIgJiYgdGhpcy5vZmZzZXQgPT09IDApIHJldHVybiB0aGlzLmJ1ZmZlcjtcblxuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKDgpO1xuICAgIHRoaXMuYnVmZmVyLmNvcHkob3V0LCAwLCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyA4KTtcbiAgICByZXR1cm4gb3V0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3B5IDggYnl0ZXMgb2YgaW50NjQgaW50byB0YXJnZXQgYnVmZmVyIGF0IHRhcmdldCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSB0YXJnZXRCdWZmZXIgICAgICAgQnVmZmVyIHRvIGNvcHkgaW50by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0YXJnZXRPZmZzZXQ9MF0gICBPZmZzZXQgaW50byB0YXJnZXQgYnVmZmVyLlxuICAgKi9cbiAgY29weTogZnVuY3Rpb24odGFyZ2V0QnVmZmVyLCB0YXJnZXRPZmZzZXQpIHtcbiAgICB0aGlzLmJ1ZmZlci5jb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0T2Zmc2V0IHx8IDAsIHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIDgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbnVtYmVyIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGNvbWVzIGJlZm9yZSBvciBhZnRlciBvciBpcyB0aGVcbiAgICogc2FtZSBhcyB0aGUgb3RoZXIgaW4gc29ydCBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtIHtJbnQ2NH0gb3RoZXIgIE90aGVyIEludDY0IHRvIGNvbXBhcmUuXG4gICAqL1xuICBjb21wYXJlOiBmdW5jdGlvbihvdGhlcikge1xuXG4gICAgLy8gSWYgc2lnbiBiaXRzIGRpZmZlciAuLi5cbiAgICBpZiAoKHRoaXMuYnVmZmVyW3RoaXMub2Zmc2V0XSAmIDB4ODApICE9IChvdGhlci5idWZmZXJbb3RoZXIub2Zmc2V0XSAmIDB4ODApKSB7XG4gICAgICByZXR1cm4gb3RoZXIuYnVmZmVyW290aGVyLm9mZnNldF0gLSB0aGlzLmJ1ZmZlclt0aGlzLm9mZnNldF07XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBjb21wYXJlIGJ5dGVzIGxleGljb2dyYXBoaWNhbGx5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLm9mZnNldCtpXSAhPT0gb3RoZXIuYnVmZmVyW290aGVyLm9mZnNldCtpXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5vZmZzZXQraV0gLSBvdGhlci5idWZmZXJbb3RoZXIub2Zmc2V0K2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGlzIGludGVnZXIgaXMgZXF1YWwgdG8gb3RoZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7SW50NjR9IG90aGVyICBPdGhlciBJbnQ2NCB0byBjb21wYXJlLlxuICAgKi9cbiAgZXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcmV0dHkgb3V0cHV0IGluIGNvbnNvbGUubG9nXG4gICAqL1xuICBpbnNwZWN0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1tJbnQ2NCB2YWx1ZTonICsgdGhpcyArICcgb2N0ZXRzOicgKyB0aGlzLnRvT2N0ZXRTdHJpbmcoJyAnKSArICddJztcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/node-int64/Int64.js\n");

/***/ })

};
;